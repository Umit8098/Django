Django tamamen bir web framework. Template ler vasıtasıyla ön yüzü de yapabiliyoruz. 
Django Rest Framework sadece backend e yönelik, endpoint.
Bu end pointleri react ya da başka bir frontend frameworkünde kullanabileceksiniz.

İlk olarak çalışacağımız alanı, environment i ,çevreyi oluşturuyoruz. Bunu niçin yapıyoruz, biz şimdi projemizde paketler yükleyeceğiz, bazı paketleri sadece bu projede kullanacağız, o yüzden biz bu paketleri global imize değil de oluşturacağımız bu environment e yüklüyoruz. 2. sebepte yüklediğimiz package ların versiyonları ile ilgili, projede hangi package ın hangi versiyonu yüklenmiş ise bu environment tan onları görüp çağırıp projeyi açabiliriz. O yüzden globalimizi kullanmayıp, bir virtual environment oluşturup bütün projeyi onu active ederek oluşturuyoruz.



### 1_ders
# create project  and "welcome backend"
# model - create student

$ python --version
$ pip --version

$ python -m venv env    (veya py -m venv env)
$ .\env\Scripts\activate

$ pip install django   # install django and       
(python -m pip install --upgrade pip  # optional -- upgrade pip version     veya 
py -m pip install --upgrade pip)

$ pip freeze    # control 
$ pip freeze > requirement.txt (projenin sonunda da yapılabilir, tekrar tekrar da yapılabilir)
(pip install -r .\requirements.txt) (Oluşturulmuş bir requirements.txt dosyasından indirme.)

$ django-admin startproject main .    (proje başlatma)

(manage.py bizim django komutlarını çalıştırmaya yarıyor. Bu dosya ile aynı seviyede olmalıyız, komutları çalıştırabilmemiz için.)


create .gitignore    (.gitignore dosyası oluşturuyoruz.)

$ gitignore template (react - django vs) : https://www.toptal.com/developers/gitignore/api/django

$ gitignore template (react - django vs) : https://www.toptal.com/developers/gitignore


create app (app oluşturuyoruz.)

$ python manage.py startapp fscohort # create a app  (veya py manage.py startapp fscohort)
$ add app to installed_apps in settings.py   (app imizi settings.py a kaydediyoruz.)

$ python manage.py runserver      (veya py manage.py runserver)
(terminalde gelen uyarı mesajı -> : Biz settings.py ile gelen default değerlerde değişiklik (app imizi ekledik) yaptığımız için bizden <py manage.py migrate> komutu istiyor. Zaten ilerde o komutu kullanacağımız için bu uyarıyı dikkate almıyoruz.)


(proje <urls.py> ından, app in <urls.py> ına yönlendirme yapıyoruz.) 
- main/urls.py >>>>> include application
  
```
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('', include("fscohort.urls")),
]
```


(app in <urls.py> ı olmadığı için bir tane <urls.py> dosyası oluşturuyoruz.) 
- fscohort/urls.py >>>> call view

```
from django.urls import path
from .views import home

urlpatterns = [
    path('', home),
]
```



(app in <urls.py> ında <views.py> dan çağırdığımız home views ını oluşturuyoruz. app in <views.py> ında da öncelikle bir HttpResponse döndürüyoruz.) 
- fscohort/views.py

```
from django.shortcuts import render
from django.http import HttpResponse

# Create your views here.

def home(request):
    return HttpResponse("Welcome to Backend")
```



(django relational db lerle daha uyumlu çalışıyor. non-relational db ler ile çalışması için 3rd party package lere ihtiyaç duyuyor. Db ayarları <settings.py> da ilgili kısımda yapılıyor.)



-------------- models ----------------

-models.py 'da Student tablosunu oluşturuyoruz;

(modelimizi yani tablomuzu oluşturduktan sonra <py manage.py makemigrations> ve <py manage.py migrate> komutlarını çalıştırıyoruz.)

$ from django.db import models
$ class Student(models.Model):
      first_name = models.CharField(max_length=20)
      last_name = models.CharField(max_length=30)
      number = models.IntegerField()



admin dashbord umuzu ayağa kaldırıyoruz;
```
py manage.py createsuperuser
```

(admin dashbord umuzda oluşturduğumuz modelimizi yani tablomuzu göremiyoruz. Onun için <admin.py> dosyasına gidip modelimizi <models.py> dan import edip admin.site.register(modelimizin ismi) ni yazmamız gerekiyor. )

```
from django.contrib import admin
from .models import Student

# Register your models here.

admin.site.register(Student)
```

(oluşan dashboard umuzda modelimize eklediğimiz objelerin görünümünü human readable yapmak için __str__ metodumuzu kullanıyoruz. __str__ metodunu yazdığımızda tekrardan makemigrations ve migrate komutlarını çalıştırmamıza gerek yok. Çünkü modelimizde değişiklik yapmıyoruz, sadece görünümünü değiştiriyoruz. Modelde değişiklik yapsaydık bu komutları çalıştırmamız gerekirdi.)

```
from django.db import models
class Student(models.Model):
    first_name = mod........
    ................

    def __str__(self):
        return (f'{self.number} - {self.first_name}')
```


(Bir de object-oriented da gösterilen inner class vardı, bir class ın altına tekrar bir class daha yazabiliyoruz. Burada Meta optionslardan bahsedildi. class Meta: ile )
```
from django.db import models
class Student(models.Model):
    first_name = mod........
    ................

    def __str__(self):
        return (f'{self.number} - {self.first_name}')

    class Meta:
        ordering = ["number"]  (database'de değişiklik yapmıyor.artan numara sırasına göre sıraladı)
        verbose_name_plural = "Student_List"  (db'de dğşklik yapmıyor.Tablonun ismini çoğul olmasını engelliyor)
        db_table = "Student_Table"      (database'de değişiklik yapıyor (tablonun ismini değiştiriyor.) o yüzden makemigrations ve migrate komutlarını çalıştırmamız gerekiyor.)
```


(Şimdi temel ORM sorguları yapacağız. Bunun için shell i kullanacağız. Normalde biz queryleri, djangonun logic kısmı views olduğundan views içerisinde yapıyoruz. Views de biz db den ORM sorgularıyla veriyi çekip template lere gönderiyoruz veya endpoint yazmışsak, API yazmışsak oraya gönderiyoruz.)
(ORM -> Object Relational Mapping diye geçiyor. Arka planda hangi db ye bağlanırsak bağlanalım MySQL, Oracle, PostgreSQL farketmez ORM sayesinde aynı komutularla query lerle istediğimiz veriyi çekebiliyoruz. Arkadaki db den bağımsız olarak python code larıyla veriyi çekebiliyoruz.)
(Normalde biz ORM sorgularını views de yapıyorduk, ama şimdi biz views e girmediğimiz için shell i kullanacağız, shell de de yapabiliriz. Bir de burda bir yapı oluşturduğumuzda, değişiklik yaptığımızda view da çağır ordan template e gönder oradan gör vs. çok uğraştırır bizi, yaptığımız değişiklik çalışıyor mu ya da yeni birşey deniyoruz mesela bunu hemen shell de ORM komutunu çağırarak hemen deneyebiliriz. Shell in bu güzelliği de var.)
(Shell i çağırıyoruz -> )
```
py manage.py shell
```
shell imiz geldi fakat çok cansız interaktif değil. 

(Şimdi daha interaktif bir şekilde shell i kullanmak için <shell_plus> yapısı var onu kullanacağız. Bunun için önce <exit()> yazıp shell den çıkıyoruz.)
```
exit()
```

(shell imizi daha kullanışlı ve interaktif hale getirmek için ->)
(Bir package yükleyeceğiz. <pip install django_extensions>)
```
pip install django_extensions
```

(Bir package daha yükleyeceğiz. <pip install ipython>)
```
pip install ipython
```

(Bu iki package den <django_extensions> package ını <INSTALLED_APPS> e yüklememiz gerekiyor.)
(<manage.py> file ının sağladığı komutlara ek olarak <django_extensions> ile ekstra birçok kabiliyet kazandırıyor. Biz bunlardan <shell_plus> ı kullanacağız. )

(Artık <shell_plus> ı kullanmak için <py manage.py shell_plus --ipython> komutunu kullanıyoruz.)
```
py manage.py shell_plus --ipython
```

(Artık terminalimizde daha interaktif bir shell sayfamız var.Burada tab a bastığımızda tamamlama özelliği de var.)

(Önce çalışacağımız tabloyu import ediyoruz.)
```
from fscohort.models import Student
```


(Artık buradan veri oluşturabiliriz.)
```
s1 = Student(first_name="Henry", last_name="Forester", number=223)
```

(Oluşturduğumuz s1 i çağırdığımızda __str__ metodu ile çağırdığız haliyle verimiz geliyor)
```
s1
Out[4]: <Student: 223 - Henry>
```

(Bu işlemlerde şöyle bir trik var; buradaki işlemler db ye kaydedilmiyor. Bunun için <s1.save()> dersek s1 e tanımladığımız obje db ye kaydedilir. ->)
```
s1.save()
```
(db ye bakıyoruz evet s1 ile tanımladığımız obje db ye <Student_Table> a kaydedilmiş.)


(Bu kayıt işlemini .save() methodu kullanmadan şu şekilde db ye kaydedebiliriz. Bu yapı ayrıca ORM in bizim standart yapısıdır. Tablonun ismi <Student.objects> dir. <Student.objects.create()> olur, <Student.objects.get()> olur, <Student.objects.filter()> olur. -> )
```
s2 = Student.objects.create(first_name="John", last_name="Doe", number=212)
```

(db ye kaydetti, s2 diye çağırdığımız zaman -> )
```
s2
Out[7]: <Student: 212 - John>
```


(modelimizde bir değişiklik yaptığımızda <migrations> ve <migrate> komutlarını çalıştırıp, shell de göremeyiz. Bunun için shell den <exit()> komutuyla çıkıp tekrar shell e girmemiz gerekiyor.)


(En çok kullanılan iki ORM sorgusunu göreceğiz. <.all()> komutu ile tüm verieri QuerySet olarak tanımlar )
```
s_all = Student.objects.all()
```

```
s_all
Out[9]: <QuerySet [<Student: 212 - John>, <Student: 223 - Henry>, <Student: 8165 - umit>, <Student: 8166 - tuğba>]>
```




(Başka çok kullanılan ORM sorgusu ->  <.get(first_name="John")> komutu ile sadece bir obje, specific bir obje döndürebiliyoruz. unique olması lazım.)
```
f1 = Student.objects.get(first_name="John")
```

```
In [11]: f1
Out[11]: <Student: 212 - John>
```

```
In [18]: f1.first_name
Out[18]: 'John'
```




(Başka çok kullanılan ORM sorgusu ->  <.filter(number=123)> komutu ile number=123 olanları filtreleyip getirdi.)
```
s3 = Student.objects.filter(number=123)
```

```
In [13]: s3
Out[13]: <QuerySet [<Student: 123 - hasan>, <Student: 123 - chris>]>
```





```
s4 = Student.objects.filter(number=212)
```

```
In [15]: s4
Out[15]: <QuerySet [<Student: 212 - John>]>
```
(Bu query de sonuç olarak queryset liste olarak döndüğü için, <QuerySet [<Student: 212 - John>] böyle verdi. biz <s4.first_name> diye çağıramayız. Ancak <s4[0].first_name> şeklinde çağırabiliriz.)

(error)
```
s4.first_name
AttributeError: 'QuerySet' object has no attribute 'first_name'
```

(successfuly)
```
In [17]: s4[0].first_name
Out[17]: 'John'
```






look up fields  (dokümandan bakıp incelenebilir.)
(j ile başlayanlar -> )
```
In [19]: f3 = Student.objects.filter(first_name__startswith="j")

In [20]: f3
Out[20]: <QuerySet [<Student: 212 - John>]>
```



(e içerenleri filtrele getir -> )
```
In [21]: f4 = Student.objects.filter(first_name__contains="e")

In [23]: f4
Out[23]: <QuerySet [<Student: 223 - Henry>, <Student: 365 - rafe>]>








      about_me = models.TimeField(null=True, blank=True)
      image = models.ImageField(null=True, blank=True, upload_to="media/")
      register_date = models.DateTimeField(auto_now_add=True)
      last_update_date = models.DateTimeField(auto_now=True)

      (ImageField kullanacağımız zaman pythonun image kütüphanesini (Pillow) yüklememiz lazım.
      $ python -m pip install Pillow    veya    $ pip install Pillow)

      ImageField kullandığımız zaman browserda resmi görebilmek için image ile ilgili bir url ayarlaması yapmamız gerekir.
      settings.py' a gidip en alt kısma

      $ MEDIA_URL = "/media/"
      $ MEDIA_ROOT = os.path.join(BASE_DIR, "media")
      belirtmemiz gerekiyor. os ' i de import etmemiz gerekiyor.

      $ import os

      (Python' da sabitler, değiştirilmezler büyük harfle yazılıyor.)

      settings' de ayar yaptıktan sonra ilgili app'in url'inde ayar yapacağız.

      önce import yapıyoruz,

      $ from django.conf import settings
      $ from django.conf.urls.static import static
      
      aşağıya da,

      $ urlpatterns +=static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)

      yazıyoruz.(Burda sorun çıktı, sorunu da modeldeki upload'ı silerek çözdük.)

      $ register_date = models.DateTimeField(auto_now_add=True)
      (auto_now_add=True -> tabloya bir student ekleyeceğimizde eklediğimiz andaki tarihi kaydediyor.)

      $ update_date = models.DateTimeField(auto_now=True)
      (auto_now=True -> tabloda, objede bir değişiklik yaptığımızda tarih ekliyor.)

      makemigrations yapınca bir trik var, önceki eklenenler ne yapayım diye soruyor, 1' i seçip time zone' u da enter diyoruz.

      ///  choices option kullanımı -> ///

      $ YEAR_IN_SCHOOL_CHOICES = [
          ('FR', 'Freshman'),
          ('SO', 'Sophomore'),
          ('JR', 'Junior'),
          ('SR', 'Senior'),
          ('GR', 'Graduate'),
        ]
      $ year_in_school = models.CharField(max_length=50,  choices=YEAR_IN_SCHOOL_CHOICES, default='FR')


      def __str__(self):
        return (f"{self.number} - {self.first_name}")
    ( def __str__(self) fonksiyonu db' de sadece görünümde bir değişiklik yapıyor, içerikte bir değişikliğe neden olmadığı için makemigrations ve migrate komutlarını çalıştırmıyoruz.)  

      class Meta:
        ordering = ["number"]                 (database'de değişiklik yapmıyor.)
        verbose_name_plural = "Student_List"  (database'de değişiklik yapmıyor.)
        db_table = "Student_Table"            (database'de değişiklik yapıyor (tablonun ismini değiştiriyor.) o yüzden makemigrations ve migrate komutlarını çalıştırmamız gerekiyor.)


$ py manage.py makemigrations

$ py manage.py migrate



-admin paneli ayağa kaldırmak için superuser oluşturuyoruz;
$ py manage.py createsuperuser  (username ve pasword giriyoruz.)

admin.py dosyasına 
$ from .models import Student
$ admin.site.register(Student)








### 2_ders

////// ORM Queries /////

(views oluşturmadığımız için orm sorguları için shell kullanacağız.Normalde queryleri views içerisinde yapıyoruz.) 

$ py manage.py shell
(ancak bu shell yeterince iyi değil)
exit()
(shell'i daha kullanışlı interactive hale getirmek için aşağıdaki paketleri yükledik.Bu paketler özellikle extensions bize extra kabiliyetler kazandırıyor.)

$ pip install django_extensions
$ pip install ipython

(django_extensions paketini install app' e yüklememiz gerekiyor.)

(Bu ikisiyle birlikte tekrar shell' i çalıştıracağız, ama komut biraz değişti)

$ py manage.py shell_plus --ipython

(Artık daha interactive bir shell'imiz var.)

$ cls (bu komut terminal ekranını temizliyor)

$ from fscohort.models import Student
$ s1 = Student(first_name="Henry", last_name="Forester", number=223)
($ s1    yazarsak terminale     <Student: 223 - Henry>  verir bize. Ancak db' ye kaydetmez. db' ye kaydetmek için s1.save() yazmamız gerekir.)

(s1.save() yazmadan kaydetmek istersek: 
$ s2 = Student.objects.create(first_name="John", last_name="Doe", number=212)  şeklinde yazmalıyız.)

(Bu aşamadan sonra eğer modelde değişiklik yaparsak, bu değişiklik shell' e yansımaz, shell den  $ exit()  ile çıkıp tekrar shell'e girmemiz gerekir. $ py manage.py shell_plus --ipython   )


/////// Sık kullanılan ORM sorguları: ///////////

$ s_all = Student.objects.all()   (s_all enter -> Student Tablomuzdaki tüm verileri queryset olarak s_all' un içine atıyor. )

$ f1 = Student.objects.get(first_name="John")   (f1 enter -> get ile specific bir obje çekiyoruz.Birden fazla varsa hata verir.)

$ s2 = Student.objects.filter(number=123)        (s2 enter -> number=123 olanları filtreleyip getirdi)

$ s3 = Student.objects.filter(number=212)        (s3 enter -> filter ile çağırırsak <QuerySet [<Student: 212 - John>]> olarak döndürüyor. $ s3.first_name dersek getirmez. s3[0].first_name dersek "John" döndürür bize. )

$ f1 = Student.objects.get(first_name="John")     (f1 enter -> get ile çağırırsak specific bir nesne geldiği için $ f1.first_name dersek bize 'John' getirir.)

$ f3 = Student.objects.filter(first_name__startswith="j")    (j ile başlayanları getir.)

$ f3 = Student.objects.filter(first_name__contains="e")      (first_name de e içerenleri getir.)


$ exit()

$ cls




Common Field Types and field options

### 3_ders

////////// realtionship ///////////

(yeni bir app oluşturuyoruz)
$ py manage.py startapp dj_relationships

1 to 1
many to 1
many to many

on_delete metodunu yazmamız gerekiyor. CASCADE : parent taki objesi silinirse bunu da sil 


genelde en çok kullanılan many to one

